a="""#.####################################################################################################
#>^<.v^^v>>^>vv..<><v.<^<^<v.^>>^<>>><><<>^v^>.^<>><<^vv><^<>>vv^v.<.^v><<<>.<v><<^v<v^<>.<vv<>vv<<v>#
#<v<vv><^>v<><.<<^^<>^>v<^vvvv^<<v<<^.^.^>.<><^><<^v<^><<v>vv<<>>>^.^<>>>^vvv^><^v^^>>><<vvv>><<><><.#
#>.vv^^^<^>v>vvv>^.<v<>...v^<>v<><<..vvv<^<<v>^>^<^v^>><^^v.v>>><^.^>vv^^v>v<^^.vv<v<v<>>^^>v>vvv^v><#
#.<v>^^<^v^^<^>>^>><v>^vv>^<v<v^^<>^v><v<^<>>.v^>^.v^><vvv^.^.>vvv^.v.>.>^<^.<^>><^><v<<v>^^>><><^^^<#
#<^<<v^vvv>>><>^^>>v.v.v^^>^<>><^>>^^><v>v<^.^.v<..>>>.>>.<^<^^^>.<>^^.v^>>>v>v>^^v>^><>><<.^.^>vv^^.#
#<^^>^v><..v^v<^.<vv^v<.<>.<>.^v^>^^>>v^^v.<.^><>^v.^^v>v<^^vv<<^^v<>><>^<v>>^<><v^.>>>>^v.>v.><.>v>>#
#<>.<<v.><^><<>>v><><>^..^v^<v>v<v.<>^<>>^v.^^>>.v^.<v>v>.v.v<>v.<.vv<<^<>^^^^>>.<vv<><<>vv>^>.v^<^>>#
#<.^<vv<><v^^<^v^.<><>v>>>.<<v<<v>>v^..v<<>^>^v>>.<>>v<^>^>^<vvv<><<<..v><<<v>><v<^v^<<^vvv>^>^<v<vv<#
#>^>^v>><<>>.^<>>^.^<v>^>>.<v^>v<<>vv><.v<.^^^>v<v>.v^v^.>>^^^vvvv<^<^<v>^.^<>v<^.^<>v>>vv<>>^^^>v>><#
#>><^<<v<>>^<^>v>v^v><v<v><^v>v>^>^<>>^v>vv^>^v<vv^v>.<^><.vv^^^<^><..<<<>^>^.^>>>^<>.^<^>^<>^^v>v<v>#
#><<><v><v^v>.v>^.<^><^^v><<<<<.^>>.^^<v>v>>^<^<>.^.>>>.>>.^v>v.<^^v^<^<>v<>^^<v^><<^^^<><v^>v>v<^.v<#
#<v>.v<<><vvv^<>^^^<<v<v^v^><v.><<.^^>vvv^>^v>v><><<.v>v<<<><..>>v>>v><^^>^^.^>v.v..>^><^.<>^<<^<<v<<#
#<vv<<vvv<vv>v><<.v<v<><.>^vv.^<<<<<<<v<^<^v^v>.v><vv<v^>^^^.^vv<<v>.<<><>>><^<^.^<>^>^<>v.v.v^><v<<.#
#.>^.>vv<v<><vv^v.^v<.^.v<><>^^>^.>v^<><v<<><vv<<^v>^>v<>^v>v>>v<>^<v.<v^^<<v><<.^<^>.vv.>>^.vv<><v><#
#>>v>>>.v<v<^^>><^^v^>>v>v^>>^<v^^^^.vv.^vv<vv><v^v<>^v<>>>>^^v>^<v<v^<>><>.v>>v..^>..<v<<>.v<<.<^>v<#
#<><^>>v^<^^vv>v<v.>.v.<^v.^>vvv<^>v><^>v><><.v>>.^^>><<>.v^<<^.<.^^.<v><v.^.v<^^^^<^<^>vv<v<.v<<v<^>#
#<<^^<<^vvv<<<<.^vv^.><<vv>v^><>..^.^^v>v>^^<<v>^v.v>^v><>>^v><<.v>v<>^v<v<>v<^v^.^<vv>>^>v>^><<v><.<#
#<<>v.v>...^^.<<^>>.<>^^^v>^<^><v<<<><<vv^.v^>.v^.>>^<v>>^<v^^<v>>vv<<>.>>.v^v><.^v.>^>^><^^v^^v<v>^<#
#<^vv^<><<<v^^<^>>v><^<<v^^v^>>^>v<>.<>>v>v<><v.>v<><<<<.<<.<<>>>><><vv><^v<<<^>v<^<^^<v^><^<..v>.vv>#
#><^>>>.^.>v<^^>>vv<v><^<<v.<.>^<^<^v>vv>v^^><.^.^>>.v.>v^.>>^<>^^^>vvv>..v^vv<^v>>v<><><<<^^<<v>^^<>#
#>^<vv>^v<<.<<v>^><><>>v.>.^<>^^vv<<>>>v^<>>><<v.v>>^<<vv<^vvv><><.v><.vv^v^.v.>vv^<><.v^>vv.<<<v<><<#
#>v<^>>.>>v>v>><^>^>^.^>^>vv>^<<><^v.<vvv<^.><>>v>v>^<>><^>^^<>v>v>.<^v^>>>v^>vvv.>.>^<><>.v^vv><>^>>#
#>><>v^>^>>^>^^>^>^<^>>vv>>>>>>vvv.v>.^v<v<vvv<<>.<^v.vv.v>^>>vv<<v^>^^^^>>^v.^v>>v<vvv<.<>^^<^v<<<.<#
#<>vv<^v>v^<v>>^<<>v^>vvvv>v^><^>^v<v^^^>><^><<.^>v^vv.v<<<>..v<^<.vv>.v>^>>>^^v^v^<^v^<^^<<vv>.>.>><#
#<<<v><>v.><v>><v^<^>><>^<vv><<.<<<<.v^v>v>v>.><>.<v><^.<^>^^><v>vv.<v>.v.>>.^>^>v<^vvvv>><>^^v<^>v>.#
#>.^>^>.<v.v<.<>vv<v<>^v<.>^>v<^v^>.>^<^..v<>>v.v>^.v<^>>^^^<v.<>v><v.^v^.>vv<<^<v^<.^^^.^>>.v>.vv.^.#
#<^v><>.<^v<v<^v<vv^^>.>v^^<v>^<.<^^<<.^>vv^^<^>v<v<^<v^^>vv^v>v^^>>..v^>.<v>v>v<v^<>^<^><.>^>>><<v.<#
#>>^<vv.<<>v.<>v.^>>^^vv^<^>vv<^>v.v>>.^.v^.v<v>^<>^.>><^>v>.>>v^<^>.>>^v<<v<<^^<vvvvv><^>^>v^^^^>^v>#
#<^.>^v>^<>>^.^<>.>..><>.<v^v^vv^>v^..v<<><>>^.^><^^<^^<^v<<^<^>.<><^.>^<^vv^>>>>^^>>><v<<<<^><.>^>.<#
#.v<>><^^vv^<<v^v><<<v<<<v><>><>>v^>v>^^^v<<<<<<>.^v<>.^<><<^vv<^>>v.^><v>v<^v>^v><v>>v<^^>vv.^<^>.>.#
#>^<.>v^^^><<v><>^.>vvv>v^<^>v><<<><><.^>>.>vv.^<<<<<^<^>^>v<^^<^<><v<.<>v<<><<v<^>>v>>>^<>>>.<<^<^<<#
#>^^>.vv^><.>v<vv>^><>v><^<v.<v^>.^><v<v>v^>^<v^v>v<<v^^<^>.^<v<vv<.>>v>v^v.<vv^^^^><v>^<>^v^>vv>>vv>#
#><>^<^^>^>v<^^<vv^<<^>v<>>v^>^v.v.v>^^><^<<<<>v>vv<v>^^<v>>.v<><<^><^^<<>>>>^>v>^>><><^>v><^^><v^^>>#
#><<<v<v><>^vv.^<>^>><v>vv^v^v<<v.v<v^>>vvvv^v<^<v^.><^^v><><v<^^<>><<>v^vv<^>v><>><<<^>>^^<^>><>v<v<#
#>^v><>v<>>^v>^<v^<vv><>^^>>>>v><v^v^>>>v<^<<<<<v<^<>>v><^<<^^^<^<>v<>^<v><^.>>><<^v.<>v^^.>>^^.^>^v<#
####################################################################################################.#"""
test="""#.#####
#.....#
#>....#
#.....#
#...v.#
#.....#
#####.#"""
test="""#.######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#"""
#a=test
b=[[x for x in y[1:-1]] for y in a.splitlines()[1:-1]]
#for y in b:
#    print("".join(y))
w,h = len(b[0]),len(b)
winds = {">":[1,0],"v":[0,1],"<":[-1,0],"^":[0,-1]}
dirs = [">","v","<","^"]
dxdy = [[1,0],[0,1],[-1,0],[0,-1]]
dxdy2 = dxdy+[[0,0]]
allRoundsWinds = []
matrices = []
roundIndex = 0
allRoundsWinds.append([[],[],[],[]])
for j,y in enumerate(b):
    for i,x in enumerate(y):
        if x != ".":
            windex = dirs.index(x)
            allRoundsWinds[roundIndex][windex].append([i,j])

#unpickling
import pickle
try:
    with open('c:/temp/matrices1.pkl', 'rb') as f:
        matrices = pickle.load(f)
except:
    for round in range(1,1000):
        if round % 10 == 0:
            print(f"init round:{round}")
        allRoundsWinds.append([[],[],[],[]])
        for windex in range(4):
            for x,y in allRoundsWinds[round-1][windex]:
                xx = (x + dxdy[windex][0]) % w
                yy = (y + dxdy[windex][1]) % h
                allRoundsWinds[round][windex].append([xx,yy])
        blank = [["." for x in range(w)] for y in range(h)]
        for i,winds in enumerate(allRoundsWinds[round]):
            for x,y in winds:
                blank[y][x] = dirs[i]
        blank = ["#."+"#"*(w)] + [["#"]+x+["#"] for x in blank]+["#"*(w)+".#"]
        matrices.append(blank)
            # for y in blank:
            #     print("".join(y))
            # print()
        #pickling
        with open('c:/temp/matrices1.pkl', 'wb') as f:
        # Pickle the list and write it to the file
            pickle.dump(matrices, f)
print(f"len matrices = {len(matrices)}")

def getDistance(pos,end):
    x,y = pos
    return abs(x-end[0]) + abs(y-end[1])

pathsVisited = {}
def addToVisited(path):
    global pathsVisited
    node = pathsVisited
    for x,y in path:
        if x not in node:
            node[x] = {}
        node = node[x]
        if y not in node:
            node[y] = {}
        node = node[y]

def isVisited(path):
    global pathsVisited
    node = pathsVisited
    for x,y in path:
        if x not in node:
            return False
        node = node[x]
        if y not in node:
            return False
        node = node[y]
    return True

qualifiedDict = {}
def enqueue(node,steps):#,path):
    global qualifiedDict,pathsVisited
    #score = steps + getDistance(node,end)
    score = getDistance(node,end)
    if score not in qualifiedDict:
        qualifiedDict[score] = {}
    if steps not in qualifiedDict[score]:
        qualifiedDict[score][steps] = []
    qualifiedDict[score][steps].append([node,steps])
    #addToVisited(path)
    

start = [1,0]
end = [w,h+1]
enqueue(start,0,)#[start])
loops = 0

def newPop():
    global qualifiedDict
    minScore = min(qualifiedDict.keys())
    minList = qualifiedDict[minScore]
    # while len(minList) == 0:
    #     del qualifiedDict[minScore]
    #     minScore = min(qualifiedDict.keys())
    #     minList = qualifiedDict[minScore]
    minSteps = max(minList.keys())
    minStep = minList[minSteps]
    # while len(minStep) == 0:
    #     del qualifiedDict[minScore][minSteps]
    #     minSteps = min(qualifiedDict[minScore].keys())
    #     minStep = qualifiedDict[minScore][minSteps]
    #minList.sort(key=lambda x: getDistance(x[0],end))
    
    returnVal = minStep.pop(0)
    if len(minStep) == 0:
        del qualifiedDict[minScore][minSteps]
        if len(qualifiedDict[minScore]) == 0:
            del qualifiedDict[minScore]
    return returnVal+[minScore]

notFound = True
while notFound:
    node,steps,score = newPop()#,path
    if node == end:
        print(f"found path in {steps} steps")
        for y in matrices[steps]:
            print("".join(y))
        notFound = False
        break
    loops += 1
    if loops % 10000 == 0:
        print(f"loops:{loops} steps:{steps} score:{score}")
        # for i,y in enumerate(matrices[steps]):
        #     if i == node[1]:
        #         print("".join(y[:node[0]])+"X"+"".join(y[node[0]+1:]))
        #     else: print("".join(y))
    candidates = []
    for d in dxdy2:
        xx = node[0] + d[0]
        yy = node[1] + d[1]
        if matrices[steps+1][yy][xx] == ".":
            candidates.append([xx,yy])
    for c in candidates:
        #newPath = path+[c]
        #if not isVisited(newPath):
        enqueue(c,steps+1)#,newPath)
        #visited.add(c)

#351 too high
