a="""#################################################################################
#........h#..........t..#...#.#e........#.............#.....#....g..#...........#
#.#######.#.#####.#####.#.#.#.#.#.#####.#.###########.#.#.###.#####.#.#.#.#####.#
#.#.....#.#.#.#...#.#...#.#.#...#.#.#...#...#.....#...#.#.....#..l#...#.#.#...#.#
#.#.###.#.#.#.#.###.#.###.#.#####.#.#.###.#.#.###.###.#####.###.#.#####.###.#.#.#
#.#.#.#.#.....#.#.........#.......#...#.#.#.#.#.#...#.....#...#.#.....#.....#.#.#
#.#.#.#.#######.###################.###.#.#.#.#.###.#####.###.#.#####.#######.#.#
#.#.#.#...#...#.........#.....#...#.#...#.#.......#.#.....#...#.#...#...#.....#.#
###I#.###.#.#.#########.#.###.#.#.#.#.#.#########.#.#####.#.###.#.#.###.#.#####.#
#...#...#.#.#.........#.#.#.#...#...#.#.#.....#...#.....#.#.#...#.#...#...#...#.#
#.###.#.#.#.#########.#.#.#.#########.#.#Q###.#.#######.#.###.#######.#######.#.#
#...#.#.....#...#.......#.#...........#.#.#...#.....#...#.....#.....#.........#.#
###.#########.#.#########.#####.###.###.#.#.#########.#######.#.###.###.###.###.#
#...#...#...#.#.........#.....#.#...#...#.#.........#.#...#...#.#.#...#.#.#.#...#
#.###.#.#.#.#.#########.#####.#.#.#####.#.#########.#.#.#.#.###.#.###.#.#.#.#.###
#.....#...#.#...#.....#...#.#.#.#.#...#.#...#.....#...#.#.#.#...#.....#...#...#.#
#.#########.###.#.#######.#.#.#.#.#.#.#.#.#.#.#########.###.#.#.#####.###.#####.#
#.#.....#.#.#.....#.......#...#.#...#.#.#.#.#.........#.....#.#.#...#.#.......#.#
#Z#.#.#.#.#.#.#####.#######.###C#####.#.###.#.#######.#.#####.###.#.#.#######.#.#
#.#.#.#...#.....#.D.#.....#.#.......#.#.#...#.#...#.#...#...#...#.#.#.....#...#.#
#.###.###.#######.###S###.#.#########.###.###.#.#.#.#####.#####.#.#.#####.###.#.#
#.#..u#...#j#...#...#.#...#.........#...#.#.#...#...#.......#.#...#.....#...#.#.#
#.#.###.###.#.#.#.#.###.###########.###.#.#.#######.#######.#.#.#######.###.#.#.#
#...#.......#r#.#.#...#...#.......#.....#.#...#...#.........#.#.......#.#.#.#...#
#.#####.#####.#.#.#.#.###.#.###.#.#####.#.###.#.#.###.#######.#########.#.#.###.#
#.#...#.#...#.#.#.#.#...#.#...#.#.#.....#...#...#.....#.....#...........#...#...#
###.#.###.#.#.#.###.#####.###.#.###.#####.#.#####.#####.###.#############.#####.#
#...#.....#...#...W.#...#s..#.#.....#...#.#.....#.#.....#..y..#.....#.....#...#.#
#F#################.#.#.###.#.#######.#.#.#####.###.#####.###.#.###.#.#####.#.#.#
#.........#.........#.#.B...#...#...#.#.#.....#.....#.#...#...#.#.#.#.......#.#.#
#####.###.###########.#########.#.#.#.#.#####.#######.#.#######.#.#.#########.###
#...#..v#...#.........#.......#...#.#.#.#.....#a......#...........#.#.....#.#...#
#.#.#######.#.#########.#####.#####.#.#.#.###########.#############.#.#.#.#.###.#
#.#.........#.#...#...#.....#.#...#.#.#.#.......#.....#..m......#...#.#.#...#...#
#.###########.#.#.###.#####.#.#.#.#.#.#########.#.###.#.#######.#.#.#.#.#####.###
#p....#n......#.#.........#.#...#...#...#.....#...#...#.#.......#.#.#.#x#.....#.#
#.###.#.#######.#########.#.#########.#.#.#.#.#####.#####.#####.#.###.#.#.#####.#
#.#.#.#.#.....#.....O...#.#.#.......#.#.#.#.#...#...#...#...#.#.#.#...#...#.....#
#.#.#.#.#.#####.#######.###.#####.#.###.#.#.#####.###.#.###.#.#.#.#.#########.#.#
#...#...#.............#...........#.......#..o........#.....#...#.............#.#
#######################################.@.#######################################
#q......M.............#.....#.....#.#.........#...#..w..........#.#.....#.......#
#######.#####.#######.#.#.#.#.###.#.#.#.#.###.###.#.###########.#.#.#.#.#####.#.#
#.....#...#...#.....#.#.#.#.#.#.#.#...#.#...#.....#...#...#...#.#...#.#...J...#.#
#.###.#####.###.#####.#.#.#.#.#.#.#####.###.#####.###.#.#.#.#.#.#####.#########.#
#.#.#.#.....#.......#.#.#.#...#.#.......#...#.#...#.#...#...#.#.......#.....#.#.#
#.#.#.#.###########.#.###.#####.#######.#.###.#.###.#########.#######.#.###V#.#.#
#.#...#.#...........#.....#.......#.....#.#...#.#.....#.#.R...#...#.#.#.#...#.#.#
#.#.###.#.###.#####.#######.###.#.#.#####.#.###.#.###.#.#.###.#.#.#.#.#.#.###U#.#
#.#.....#...#...#.#.#.......#.#.#.#.#...#.#...#...#.#.#.#...#.#.#.#..d#.#...#...#
#.#########.###.#.#.#.#######.#.#.#.###.#.#.#.#####.#.#.###.###.#.#####.###.#.###
#.#...#.......#.#...#...#.....#.#.#.#...#.#.#.#...........#....f#.......#.P.#...#
#.#.#.#########.#.#####.#.#####.#.#.#.###.#.#.#.#######.###########.#####.#####.#
#.Y.#.......#...#.....#.#...#...#.#.#...#.#.#...#.#...#.#.....#...#...#...#...#.#
#.#########.#.#####.###.###.#.###.#.###.#.#.#####.#.#.###.###.#.#.#####.###.###.#
#.#...#.....#.#.....#...#...#...#.#...#.#.#.#.....#.#.....#...#.#.......#...#...#
#.#.#.#.#####.#.#####.###.#.###.#####.#.#.#.#.###.#.#######.###N#########.###.###
#...#.#.#...#.#.....#...#.#...#.....#.#.#.#...#...#...#.....#...#.#.........#...#
#####.#.#.#.#.#########.#.###.#####.#.#.#.#####.#####.#.###.#.###.#.#######.###.#
#...#.#...#.#.............#.....#...#...#.#...#...#...#...#.#.#...#...#...#..z#.#
#K###.#####.#.###################.#####.#.#.#.###.#.#####.#.#.#.#.###.#.#.#.#.#.#
#.....#...#.#.#.....#.....#.....#.....#.#.#.#...#.#...#...#.#b#.#...#...#.#.#.#.#
#####.#.###.#.#####.#####.#.###.#####.#.#.#.###.###.###.###.#######.#####.#.###.#
#...#.#.#...#...#.......#...#.#.....#.#.#...#.#.#...#...#.........#...#...#.....#
#.#.#.#.#.#####.#.#####.#####.#####.#.#.#.###.#.#.###.###########.#.#.#.#########
#.#.#...#.#...#...#...#...#.#...#...#...#.#.A.#.....#.....#..k..#.#.#.#.#.......#
#.#.#####.###.#####.#####.#.#.#.#.###.###.###.#######.###.#####.#.#.###.#.#######
#.#.......#.......#.....#.#...#.#...#...#.......#...#.#.#.....#...#.#...#.......#
#X#########.#####.#.###.#.#####.###.#####.#######.#.#.#.#####.#.###.#.###.#####.#
#.....#.......#...#.#.#.#...#.....#.....#.#.......#.#...#.....#...#.#...#.....#.#
#####.#.#####.#.###.#.#.###.#.#########.###.#######.###.#.#######.#.###.#.#####.#
#.....#...#...#...#.#.#.....#.#...#.....#...#.....#.#...#.#.#.....#...#.#.#...#.#
#.#######.#.#######.#.#######.#.#.#.#####.#####.###.#####.#.#.#####.#.#.###.#.#.#
#.......#.#.............#.....#.#...#...#.....#.......#...#...#.....#.#.....#.#.#
#.#####.###############.#.###.#.#####.#.#.###.#######.#.###.#######.#.#######.#.#
#.#.....#...T.....#...#.#.#...#.....#.#.#...#.......#...#......c....#.......#...#
###.###.#.#######.#H#.#.#.#.#######.#.#####.#######.#####.#####.###############.#
#...#...#.#.#.....#.#.#...#...#.....#...#...#.E...#...#...#...#.#.......#.......#
#.#######.#.#.#####.#.#########.#######.#.###.###.###.#####.#.###.#####.#.#######
#.....L.....#.......#.............G..i..#.....#.....#.......#.........#.........#
#################################################################################"""


test="""#########
#b.A.@.a#
#########"""

test="""########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################"""

test="""########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################"""

test="""#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################"""

# test="""########################
# #@..............ac.GI.b#
# ###d#e#f################
# ###A#B#C################
# ###g#h#i################
# ########################"""


#a=test
b=a.replace("#","▒").replace("."," ")
grid=[[x for x in y] for y in b.splitlines()]


w,h = len(grid[0]),len(grid)

dirs = [[1,0],[0,1],[-1,0],[0,-1]]

def getNeighs(x,y): return [(x+dx, y+dy) for dx,dy in dirs]

def readNeigh(neigh):
    xx,yy = neigh
    if -1<xx<w and -1<yy<h:
        return grid[yy][xx]
    else: return "█"

def getConnectionCount(x,y): return 4-[readNeigh(neigh) for neigh in getNeighs(x,y)].count("▒")

def isJunction(x,y): return getConnectionCount(x,y) > 2 and readNeigh((x,y)) not in "▒"

def isDeadEnd(x,y): return getConnectionCount(x,y) == 1 and readNeigh((x,y)) not in "█▒"

def isHall(x,y): return getConnectionCount(x,y) == 2 and readNeigh((x,y)) not in "█▒"


def trim(x,y):
    #  grid[y][x] = "█"
    trimList=[(x,y)]
    breakFlag=False
    while not breakFlag:
        neighs = getNeighs(x,y)
        for neigh in neighs:
            if neigh in trimList or readNeigh(neigh)=="▒": continue
            xx,yy=neigh
            if isJunction(xx,yy) or readNeigh(neigh).isalpha(): 
                for xxx,yyy in trimList:
                    grid[yyy][xxx] = "▒"
                breakFlag=True
                break
            if  isHall(xx,yy): 
                trimList.append(neigh)
                x,y=neigh

def countAlphs():
    counter=0
    for j,y in enumerate(grid):
        for i,x in enumerate(y):
            if x.isalpha():counter+=1
    return counter

#delete dead ends
while any([any([isDeadEnd(i,j) and readNeigh((i,j))==" " for i in range(w)]) for j in range(h)]):
    for j,y in enumerate(grid):
        for i,x in enumerate(y):
            if x not in "█▒":
                if isDeadEnd(i,j) and readNeigh((i,j))==" ": trim(i,j)

for j,line in enumerate(grid):
    if "@" in line:
        globalStart = (line.index("@"),j)
k,l=globalStart
#remove start tile
# if test!=a:
#     grid[l][k] = "▒"

#light up junctions
for j,y in enumerate(grid):
    for i,x in enumerate(y):
        if x not in "█▒":
            if isJunction(i,j) : grid[j][i]="█" #and not (i,j)==globalStart

for line in grid:
    print("".join([x*2 for x in line]))

def walk(x,y):
    queue = [(x,y,0)]
    seen = {(x,y):0}
    paths={}
    while queue:
        x,y,dist = queue.pop()
        neighs = getNeighs(x,y)
        for neigh in neighs:
            xx,yy = neigh
            if readNeigh(neigh)=="▒" or (xx,yy) in seen: continue
            seen[neigh]=dist+1
            if readNeigh(neigh)==" ":
                queue.append((xx,yy,dist+1))
            else:
                paths[neigh]=dist+1
    return paths

def bfs():
    k,l=globalStart
    tree={}
    queue=[globalStart]#[(k-1,l-1)]
    while queue:
        node = queue.pop(0)
        x,y=node
        if readNeigh(node).isalpha(): node=readNeigh(node)
        if node not in tree: tree[node] = {}
        dic=walk(x,y)
        for dest,dist in dic.items():
            char = readNeigh(dest)
            if not char.isalpha():char=dest
            if char not in tree:
                tree[char] = {}
                queue.append(dest)
            tree[char][node] = dist
            tree[node][char] = dist
    return tree


tree = bfs()
for x in sorted(list([x for x in tree.keys() if type(x)==tuple])): print(x,tree[x])
for x in sorted(list([x for x in tree.keys() if type(x)==str])): print(x,tree[x])

def bfs2(start):
    seen={}
    queue=[(start,0,[],[])]
    while queue:
        node,dist,doors,keys = queue.pop()
        print(start,node,dist,doors,keys)
        if node not in seen: seen[node] = [dist,doors[::],keys[::]]
        elif seen[node][0] <= dist: continue
        for dest,dist2 in tree[node].items():
            newDoors=doors[::]
            newKeys=keys[::]
            if type(dest)==str:
                if dest.upper()==dest: newDoors.append(dest)
                if dest.lower()==dest: newKeys.append(dest)
            queue.append((dest,dist+dist2,newDoors,newKeys))
    return seen

allKeys = sorted([y for y in [x for x in tree if type(x)==str] if y.lower()==y])
allDoors = sorted([y for y in [x for x in tree if type(x)==str] if y.upper()==y])
keyTree={}
sx,sy=globalStart
for start in allKeys+[globalStart]:
    keyTree[start]={}
    dic = bfs2(start)
    for key in dic:
        if type(key) != str: continue
        if key==start or key not in allKeys:continue
        keyTree[start][key]={}
        dist,doors,keys = dic[key]
        keyTree[start][key]["dist"] = dist
        keyTree[start][key]["doorsAndKeysInTheWay"] = sorted([x.lower() for x in doors]+[x.lower() for x in keys if x!=key])
       # keyTree[start][key]["keysInTheWay"] = sorted([x.lower() for x in keys if x!=key])
for x in keyTree: 
    for y in keyTree[x]:
        print(x,"=>",y,keyTree[x][y])
answer = 7436
calibration = 100
while answer == 7436:
    calibration += 100
    def bfs3():
        iterations=0
        seen={}
        seenPathOrder = {}
        queue=[(globalStart,0,"","")]
        while queue:
            node,dist,keysStr,path=queue.pop()
            iterations+=1
            if iterations % 1_000_000==0: print(iterations,len(queue))
            neighs = [x for x in keyTree[node] if x not in keysStr]
            for neigh in neighs:
                neighObj = keyTree[node][neigh]
                if all([doorOrKey in keysStr for doorOrKey in neighObj["doorsAndKeysInTheWay"]]): #and all([key in keysStr for key in neighObj["keysInTheWay"]]):
                    newKeysStr = "".join(sorted(list(keysStr)+[neigh])) if neigh not in keysStr else keysStr[::]
                    newDist = dist + neighObj["dist"]
                    newPath = path + neigh
                    seenVal = seen.setdefault(newKeysStr,newDist)
                    seenPathOrder.setdefault(newKeysStr,newPath)
                    if newDist - calibration > seenVal: continue
                    if newDist <= seenVal: 
                        seen[newKeysStr] = newDist
                        seenPathOrder[newKeysStr] = newPath
                    queue.append((neigh, newDist, newKeysStr, newPath))
        allKeysSorted = "".join(allKeys)
        return seen[allKeysSorted],seenPathOrder[allKeysSorted]
    answer = bfs3()
    print(answer)

#6430 too low
#7448 too high
#7444 too high #-70
#7436 too high